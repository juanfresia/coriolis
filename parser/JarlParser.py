# Generated from Jarl.g4 by ANTLR 4.7.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3 ")
        buf.write("\u00dc\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\3\2\7\28\n\2\f\2\16\2;\13\2")
        buf.write("\3\2\3\2\3\3\7\3@\n\3\f\3\16\3C\13\3\3\3\3\3\5\3G\n\3")
        buf.write("\3\3\3\3\7\3K\n\3\f\3\16\3N\13\3\3\4\3\4\3\5\5\5S\n\5")
        buf.write("\3\5\3\5\3\6\5\6X\n\6\3\6\3\6\3\7\3\7\3\7\5\7_\n\7\3\b")
        buf.write("\3\b\3\b\5\bd\n\b\3\b\5\bg\n\b\3\b\5\bj\n\b\3\t\3\t\3")
        buf.write("\t\3\t\7\tp\n\t\f\t\16\ts\13\t\3\t\5\tv\n\t\3\t\5\ty\n")
        buf.write("\t\3\t\5\t|\n\t\3\n\3\n\5\n\u0080\n\n\3\n\7\n\u0083\n")
        buf.write("\n\f\n\16\n\u0086\13\n\3\13\3\13\3\13\3\f\3\f\3\f\3\r")
        buf.write("\3\r\3\r\3\16\3\16\3\16\3\17\3\17\3\17\3\17\3\17\3\17")
        buf.write("\3\20\3\20\3\20\3\21\3\21\5\21\u009f\n\21\3\22\3\22\5")
        buf.write("\22\u00a3\n\22\3\22\3\22\5\22\u00a7\n\22\3\23\3\23\5\23")
        buf.write("\u00ab\n\23\3\23\3\23\3\23\3\24\3\24\3\24\3\24\5\24\u00b4")
        buf.write("\n\24\3\24\3\24\3\24\3\25\3\25\3\25\7\25\u00bc\n\25\f")
        buf.write("\25\16\25\u00bf\13\25\3\26\3\26\3\26\3\26\5\26\u00c5\n")
        buf.write("\26\3\27\3\27\3\30\3\30\3\30\3\30\3\31\3\31\3\31\7\31")
        buf.write("\u00d0\n\31\f\31\16\31\u00d3\13\31\5\31\u00d5\n\31\3\32")
        buf.write("\3\32\3\32\3\33\3\33\3\33\2\2\34\2\4\6\b\n\f\16\20\22")
        buf.write("\24\26\30\32\34\36 \"$&(*,.\60\62\64\2\5\4\2\23\23\26")
        buf.write("\26\4\2\t\t\r\r\4\2\32\32\35\35\2\u00dc\29\3\2\2\2\4A")
        buf.write("\3\2\2\2\6O\3\2\2\2\bR\3\2\2\2\nW\3\2\2\2\f[\3\2\2\2\16")
        buf.write("c\3\2\2\2\20k\3\2\2\2\22}\3\2\2\2\24\u0087\3\2\2\2\26")
        buf.write("\u008a\3\2\2\2\30\u008d\3\2\2\2\32\u0090\3\2\2\2\34\u0093")
        buf.write("\3\2\2\2\36\u0099\3\2\2\2 \u009e\3\2\2\2\"\u00a0\3\2\2")
        buf.write("\2$\u00a8\3\2\2\2&\u00b3\3\2\2\2(\u00b8\3\2\2\2*\u00c0")
        buf.write("\3\2\2\2,\u00c6\3\2\2\2.\u00c8\3\2\2\2\60\u00d4\3\2\2")
        buf.write("\2\62\u00d6\3\2\2\2\64\u00d9\3\2\2\2\668\5\4\3\2\67\66")
        buf.write("\3\2\2\28;\3\2\2\29\67\3\2\2\29:\3\2\2\2:<\3\2\2\2;9\3")
        buf.write("\2\2\2<=\7\2\2\3=\3\3\2\2\2>@\7\37\2\2?>\3\2\2\2@C\3\2")
        buf.write("\2\2A?\3\2\2\2AB\3\2\2\2BD\3\2\2\2CA\3\2\2\2DF\5\6\4\2")
        buf.write("EG\5\b\5\2FE\3\2\2\2FG\3\2\2\2GH\3\2\2\2HL\5\n\6\2IK\7")
        buf.write("\37\2\2JI\3\2\2\2KN\3\2\2\2LJ\3\2\2\2LM\3\2\2\2M\5\3\2")
        buf.write("\2\2NL\3\2\2\2OP\5\f\7\2P\7\3\2\2\2QS\5\20\t\2RQ\3\2\2")
        buf.write("\2RS\3\2\2\2ST\3\2\2\2TU\5\16\b\2U\t\3\2\2\2VX\5\20\t")
        buf.write("\2WV\3\2\2\2WX\3\2\2\2XY\3\2\2\2YZ\5\22\n\2Z\13\3\2\2")
        buf.write("\2[\\\7\27\2\2\\^\7\33\2\2]_\7\37\2\2^]\3\2\2\2^_\3\2")
        buf.write("\2\2_\r\3\2\2\2`d\5\30\r\2ad\5\32\16\2bd\5\34\17\2c`\3")
        buf.write("\2\2\2ca\3\2\2\2cb\3\2\2\2df\3\2\2\2eg\7\34\2\2fe\3\2")
        buf.write("\2\2fg\3\2\2\2gi\3\2\2\2hj\7\37\2\2ih\3\2\2\2ij\3\2\2")
        buf.write("\2j\17\3\2\2\2kl\7\16\2\2lq\5\24\13\2mn\7\b\2\2np\5\24")
        buf.write("\13\2om\3\2\2\2ps\3\2\2\2qo\3\2\2\2qr\3\2\2\2ru\3\2\2")
        buf.write("\2sq\3\2\2\2tv\5\26\f\2ut\3\2\2\2uv\3\2\2\2vx\3\2\2\2")
        buf.write("wy\7\34\2\2xw\3\2\2\2xy\3\2\2\2y{\3\2\2\2z|\7\37\2\2{")
        buf.write("z\3\2\2\2{|\3\2\2\2|\21\3\2\2\2}\u0084\5\36\20\2~\u0080")
        buf.write("\7\37\2\2\177~\3\2\2\2\177\u0080\3\2\2\2\u0080\u0081\3")
        buf.write("\2\2\2\u0081\u0083\5\36\20\2\u0082\177\3\2\2\2\u0083\u0086")
        buf.write("\3\2\2\2\u0084\u0082\3\2\2\2\u0084\u0085\3\2\2\2\u0085")
        buf.write("\23\3\2\2\2\u0086\u0084\3\2\2\2\u0087\u0088\5,\27\2\u0088")
        buf.write("\u0089\5\60\31\2\u0089\25\3\2\2\2\u008a\u008b\7\31\2\2")
        buf.write("\u008b\u008c\5(\25\2\u008c\27\3\2\2\2\u008d\u008e\7\7")
        buf.write("\2\2\u008e\u008f\5\62\32\2\u008f\31\3\2\2\2\u0090\u0091")
        buf.write("\7\13\2\2\u0091\u0092\5\62\32\2\u0092\33\3\2\2\2\u0093")
        buf.write("\u0094\7\f\2\2\u0094\u0095\5\62\32\2\u0095\u0096\7\b\2")
        buf.write("\2\u0096\u0097\t\2\2\2\u0097\u0098\5\62\32\2\u0098\35")
        buf.write("\3\2\2\2\u0099\u009a\5\62\32\2\u009a\u009b\5 \21\2\u009b")
        buf.write("\37\3\2\2\2\u009c\u009f\5\"\22\2\u009d\u009f\5$\23\2\u009e")
        buf.write("\u009c\3\2\2\2\u009e\u009d\3\2\2\2\u009f!\3\2\2\2\u00a0")
        buf.write("\u00a2\7\22\2\2\u00a1\u00a3\7\24\2\2\u00a2\u00a1\3\2\2")
        buf.write("\2\u00a2\u00a3\3\2\2\2\u00a3\u00a4\3\2\2\2\u00a4\u00a6")
        buf.write("\7\17\2\2\u00a5\u00a7\5&\24\2\u00a6\u00a5\3\2\2\2\u00a6")
        buf.write("\u00a7\3\2\2\2\u00a7#\3\2\2\2\u00a8\u00aa\7\22\2\2\u00a9")
        buf.write("\u00ab\7\24\2\2\u00aa\u00a9\3\2\2\2\u00aa\u00ab\3\2\2")
        buf.write("\2\u00ab\u00ac\3\2\2\2\u00ac\u00ad\7\25\2\2\u00ad\u00ae")
        buf.write("\5\62\32\2\u00ae%\3\2\2\2\u00af\u00b0\7\n\2\2\u00b0\u00b4")
        buf.write("\7\21\2\2\u00b1\u00b2\7\n\2\2\u00b2\u00b4\7\20\2\2\u00b3")
        buf.write("\u00af\3\2\2\2\u00b3\u00b1\3\2\2\2\u00b3\u00b4\3\2\2\2")
        buf.write("\u00b4\u00b5\3\2\2\2\u00b5\u00b6\7\32\2\2\u00b6\u00b7")
        buf.write("\7\30\2\2\u00b7\'\3\2\2\2\u00b8\u00bd\5*\26\2\u00b9\u00ba")
        buf.write("\7\3\2\2\u00ba\u00bc\5*\26\2\u00bb\u00b9\3\2\2\2\u00bc")
        buf.write("\u00bf\3\2\2\2\u00bd\u00bb\3\2\2\2\u00bd\u00be\3\2\2\2")
        buf.write("\u00be)\3\2\2\2\u00bf\u00bd\3\2\2\2\u00c0\u00c1\7\33\2")
        buf.write("\2\u00c1\u00c4\7\6\2\2\u00c2\u00c5\7\33\2\2\u00c3\u00c5")
        buf.write("\5\64\33\2\u00c4\u00c2\3\2\2\2\u00c4\u00c3\3\2\2\2\u00c5")
        buf.write("+\3\2\2\2\u00c6\u00c7\t\3\2\2\u00c7-\3\2\2\2\u00c8\u00c9")
        buf.write("\7\4\2\2\u00c9\u00ca\5\60\31\2\u00ca\u00cb\7\5\2\2\u00cb")
        buf.write("/\3\2\2\2\u00cc\u00d1\7\33\2\2\u00cd\u00ce\7\3\2\2\u00ce")
        buf.write("\u00d0\7\33\2\2\u00cf\u00cd\3\2\2\2\u00d0\u00d3\3\2\2")
        buf.write("\2\u00d1\u00cf\3\2\2\2\u00d1\u00d2\3\2\2\2\u00d2\u00d5")
        buf.write("\3\2\2\2\u00d3\u00d1\3\2\2\2\u00d4\u00cc\3\2\2\2\u00d4")
        buf.write("\u00d5\3\2\2\2\u00d5\61\3\2\2\2\u00d6\u00d7\7\33\2\2\u00d7")
        buf.write("\u00d8\5.\30\2\u00d8\63\3\2\2\2\u00d9\u00da\t\4\2\2\u00da")
        buf.write("\65\3\2\2\2\339AFLRW^cfiqux{\177\u0084\u009e\u00a2\u00a6")
        buf.write("\u00aa\u00b3\u00bd\u00c4\u00d1\u00d4")
        return buf.getvalue()


class JarlParser (Parser):

    grammarFileName = "Jarl.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [DFA(ds, i) for i, ds in enumerate(atn.decisionToState)]

    sharedContextCache = PredictionContextCache()

    literalNames = ["<INVALID>", "','", "'('", "')'", "<INVALID>", "'after'",
                    "'and'", "'any'", "'at'", "'before'", "'between'",
                    "'every'", "'for'", "'happen'", "'least'", "'most'",
                    "'must'", "'next'", "'not'", "'precede'", "'previous'",
                    "'rule'", "'times'", "'with'", "<INVALID>", "<INVALID>",
                    "':'"]

    symbolicNames = ["<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                     "COMPARATOR", "AFTER", "AND", "ANY", "AT", "BEFORE",
                     "BETWEEN", "EVERY", "FOR", "HAPPEN", "LEAST", "MOST",
                     "MUST", "NEXT", "NOT", "PRECEDE", "PREVIOUS", "RULE",
                     "TIMES", "WITH", "NUMBER", "IDENTIFIER", "COLON",
                     "LITERAL_STR", "WHITESPACE", "NEWLINE", "COMMENT"]

    RULE_jarl = 0
    RULE_jarl_rule = 1
    RULE_rule_header = 2
    RULE_rule_scope = 3
    RULE_rule_fact = 4
    RULE_header_expr = 5
    RULE_selector_expr = 6
    RULE_filter_expr = 7
    RULE_fact_expr = 8
    RULE_quantifier_clause = 9
    RULE_with_clause = 10
    RULE_after_clause = 11
    RULE_before_clause = 12
    RULE_between_clause = 13
    RULE_fact_clause = 14
    RULE_requirement = 15
    RULE_requirement_count = 16
    RULE_requirement_order = 17
    RULE_how_many = 18
    RULE_condition_list = 19
    RULE_condition = 20
    RULE_quantifier = 21
    RULE_arguments = 22
    RULE_identifier_list = 23
    RULE_checkpoint = 24
    RULE_literal = 25

    ruleNames = ["jarl", "jarl_rule", "rule_header", "rule_scope", "rule_fact",
                 "header_expr", "selector_expr", "filter_expr", "fact_expr",
                 "quantifier_clause", "with_clause", "after_clause", "before_clause",
                 "between_clause", "fact_clause", "requirement", "requirement_count",
                 "requirement_order", "how_many", "condition_list", "condition",
                 "quantifier", "arguments", "identifier_list", "checkpoint",
                 "literal"]

    EOF = Token.EOF
    T__0 = 1
    T__1 = 2
    T__2 = 3
    COMPARATOR = 4
    AFTER = 5
    AND = 6
    ANY = 7
    AT = 8
    BEFORE = 9
    BETWEEN = 10
    EVERY = 11
    FOR = 12
    HAPPEN = 13
    LEAST = 14
    MOST = 15
    MUST = 16
    NEXT = 17
    NOT = 18
    PRECEDE = 19
    PREVIOUS = 20
    RULE = 21
    TIMES = 22
    WITH = 23
    NUMBER = 24
    IDENTIFIER = 25
    COLON = 26
    LITERAL_STR = 27
    WHITESPACE = 28
    NEWLINE = 29
    COMMENT = 30

    def __init__(self, input: TokenStream, output: TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None

    class JarlContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(JarlParser.EOF, 0)

        def jarl_rule(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(JarlParser.Jarl_ruleContext)
            else:
                return self.getTypedRuleContext(JarlParser.Jarl_ruleContext, i)

        def getRuleIndex(self):
            return JarlParser.RULE_jarl

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterJarl"):
                listener.enterJarl(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitJarl"):
                listener.exitJarl(self)

    def jarl(self):

        localctx = JarlParser.JarlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_jarl)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 55
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == JarlParser.RULE or _la == JarlParser.NEWLINE:
                self.state = 52
                self.jarl_rule()
                self.state = 57
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 58
            self.match(JarlParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Jarl_ruleContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def rule_header(self):
            return self.getTypedRuleContext(JarlParser.Rule_headerContext, 0)

        def rule_fact(self):
            return self.getTypedRuleContext(JarlParser.Rule_factContext, 0)

        def NEWLINE(self, i: int = None):
            if i is None:
                return self.getTokens(JarlParser.NEWLINE)
            else:
                return self.getToken(JarlParser.NEWLINE, i)

        def rule_scope(self):
            return self.getTypedRuleContext(JarlParser.Rule_scopeContext, 0)

        def getRuleIndex(self):
            return JarlParser.RULE_jarl_rule

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterJarl_rule"):
                listener.enterJarl_rule(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitJarl_rule"):
                listener.exitJarl_rule(self)

    def jarl_rule(self):

        localctx = JarlParser.Jarl_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_jarl_rule)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 63
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == JarlParser.NEWLINE:
                self.state = 60
                self.match(JarlParser.NEWLINE)
                self.state = 65
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 66
            self.rule_header()
            self.state = 68
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 2, self._ctx)
            if la_ == 1:
                self.state = 67
                self.rule_scope()

            self.state = 70
            self.rule_fact()
            self.state = 74
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 3, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 71
                    self.match(JarlParser.NEWLINE)
                self.state = 76
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 3, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Rule_headerContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def header_expr(self):
            return self.getTypedRuleContext(JarlParser.Header_exprContext, 0)

        def getRuleIndex(self):
            return JarlParser.RULE_rule_header

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRule_header"):
                listener.enterRule_header(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRule_header"):
                listener.exitRule_header(self)

    def rule_header(self):

        localctx = JarlParser.Rule_headerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_rule_header)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 77
            self.header_expr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Rule_scopeContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def selector_expr(self):
            return self.getTypedRuleContext(JarlParser.Selector_exprContext, 0)

        def filter_expr(self):
            return self.getTypedRuleContext(JarlParser.Filter_exprContext, 0)

        def getRuleIndex(self):
            return JarlParser.RULE_rule_scope

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRule_scope"):
                listener.enterRule_scope(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRule_scope"):
                listener.exitRule_scope(self)

    def rule_scope(self):

        localctx = JarlParser.Rule_scopeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_rule_scope)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 80
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == JarlParser.FOR:
                self.state = 79
                self.filter_expr()

            self.state = 82
            self.selector_expr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Rule_factContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fact_expr(self):
            return self.getTypedRuleContext(JarlParser.Fact_exprContext, 0)

        def filter_expr(self):
            return self.getTypedRuleContext(JarlParser.Filter_exprContext, 0)

        def getRuleIndex(self):
            return JarlParser.RULE_rule_fact

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRule_fact"):
                listener.enterRule_fact(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRule_fact"):
                listener.exitRule_fact(self)

    def rule_fact(self):

        localctx = JarlParser.Rule_factContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_rule_fact)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 85
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == JarlParser.FOR:
                self.state = 84
                self.filter_expr()

            self.state = 87
            self.fact_expr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Header_exprContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RULE(self):
            return self.getToken(JarlParser.RULE, 0)

        def IDENTIFIER(self):
            return self.getToken(JarlParser.IDENTIFIER, 0)

        def NEWLINE(self):
            return self.getToken(JarlParser.NEWLINE, 0)

        def getRuleIndex(self):
            return JarlParser.RULE_header_expr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterHeader_expr"):
                listener.enterHeader_expr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitHeader_expr"):
                listener.exitHeader_expr(self)

    def header_expr(self):

        localctx = JarlParser.Header_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_header_expr)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 89
            self.match(JarlParser.RULE)
            self.state = 90
            self.match(JarlParser.IDENTIFIER)
            self.state = 92
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == JarlParser.NEWLINE:
                self.state = 91
                self.match(JarlParser.NEWLINE)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Selector_exprContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def after_clause(self):
            return self.getTypedRuleContext(JarlParser.After_clauseContext, 0)

        def before_clause(self):
            return self.getTypedRuleContext(JarlParser.Before_clauseContext, 0)

        def between_clause(self):
            return self.getTypedRuleContext(JarlParser.Between_clauseContext, 0)

        def COLON(self):
            return self.getToken(JarlParser.COLON, 0)

        def NEWLINE(self):
            return self.getToken(JarlParser.NEWLINE, 0)

        def getRuleIndex(self):
            return JarlParser.RULE_selector_expr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSelector_expr"):
                listener.enterSelector_expr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSelector_expr"):
                listener.exitSelector_expr(self)

    def selector_expr(self):

        localctx = JarlParser.Selector_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_selector_expr)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 97
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JarlParser.AFTER]:
                self.state = 94
                self.after_clause()
                pass
            elif token in [JarlParser.BEFORE]:
                self.state = 95
                self.before_clause()
                pass
            elif token in [JarlParser.BETWEEN]:
                self.state = 96
                self.between_clause()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 100
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == JarlParser.COLON:
                self.state = 99
                self.match(JarlParser.COLON)

            self.state = 103
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == JarlParser.NEWLINE:
                self.state = 102
                self.match(JarlParser.NEWLINE)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Filter_exprContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(JarlParser.FOR, 0)

        def quantifier_clause(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(JarlParser.Quantifier_clauseContext)
            else:
                return self.getTypedRuleContext(JarlParser.Quantifier_clauseContext, i)

        def AND(self, i: int = None):
            if i is None:
                return self.getTokens(JarlParser.AND)
            else:
                return self.getToken(JarlParser.AND, i)

        def with_clause(self):
            return self.getTypedRuleContext(JarlParser.With_clauseContext, 0)

        def COLON(self):
            return self.getToken(JarlParser.COLON, 0)

        def NEWLINE(self):
            return self.getToken(JarlParser.NEWLINE, 0)

        def getRuleIndex(self):
            return JarlParser.RULE_filter_expr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFilter_expr"):
                listener.enterFilter_expr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFilter_expr"):
                listener.exitFilter_expr(self)

    def filter_expr(self):

        localctx = JarlParser.Filter_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_filter_expr)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 105
            self.match(JarlParser.FOR)
            self.state = 106
            self.quantifier_clause()
            self.state = 111
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == JarlParser.AND:
                self.state = 107
                self.match(JarlParser.AND)
                self.state = 108
                self.quantifier_clause()
                self.state = 113
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 115
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == JarlParser.WITH:
                self.state = 114
                self.with_clause()

            self.state = 118
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == JarlParser.COLON:
                self.state = 117
                self.match(JarlParser.COLON)

            self.state = 121
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == JarlParser.NEWLINE:
                self.state = 120
                self.match(JarlParser.NEWLINE)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Fact_exprContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fact_clause(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(JarlParser.Fact_clauseContext)
            else:
                return self.getTypedRuleContext(JarlParser.Fact_clauseContext, i)

        def NEWLINE(self, i: int = None):
            if i is None:
                return self.getTokens(JarlParser.NEWLINE)
            else:
                return self.getToken(JarlParser.NEWLINE, i)

        def getRuleIndex(self):
            return JarlParser.RULE_fact_expr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFact_expr"):
                listener.enterFact_expr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFact_expr"):
                listener.exitFact_expr(self)

    def fact_expr(self):

        localctx = JarlParser.Fact_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_fact_expr)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 123
            self.fact_clause()
            self.state = 130
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 15, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 125
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la == JarlParser.NEWLINE:
                        self.state = 124
                        self.match(JarlParser.NEWLINE)

                    self.state = 127
                    self.fact_clause()
                self.state = 132
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 15, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Quantifier_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def quantifier(self):
            return self.getTypedRuleContext(JarlParser.QuantifierContext, 0)

        def identifier_list(self):
            return self.getTypedRuleContext(JarlParser.Identifier_listContext, 0)

        def getRuleIndex(self):
            return JarlParser.RULE_quantifier_clause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterQuantifier_clause"):
                listener.enterQuantifier_clause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitQuantifier_clause"):
                listener.exitQuantifier_clause(self)

    def quantifier_clause(self):

        localctx = JarlParser.Quantifier_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_quantifier_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 133
            self.quantifier()
            self.state = 134
            self.identifier_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class With_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH(self):
            return self.getToken(JarlParser.WITH, 0)

        def condition_list(self):
            return self.getTypedRuleContext(JarlParser.Condition_listContext, 0)

        def getRuleIndex(self):
            return JarlParser.RULE_with_clause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterWith_clause"):
                listener.enterWith_clause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitWith_clause"):
                listener.exitWith_clause(self)

    def with_clause(self):

        localctx = JarlParser.With_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_with_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 136
            self.match(JarlParser.WITH)
            self.state = 137
            self.condition_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class After_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AFTER(self):
            return self.getToken(JarlParser.AFTER, 0)

        def checkpoint(self):
            return self.getTypedRuleContext(JarlParser.CheckpointContext, 0)

        def getRuleIndex(self):
            return JarlParser.RULE_after_clause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAfter_clause"):
                listener.enterAfter_clause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAfter_clause"):
                listener.exitAfter_clause(self)

    def after_clause(self):

        localctx = JarlParser.After_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_after_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 139
            self.match(JarlParser.AFTER)
            self.state = 140
            self.checkpoint()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Before_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BEFORE(self):
            return self.getToken(JarlParser.BEFORE, 0)

        def checkpoint(self):
            return self.getTypedRuleContext(JarlParser.CheckpointContext, 0)

        def getRuleIndex(self):
            return JarlParser.RULE_before_clause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBefore_clause"):
                listener.enterBefore_clause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBefore_clause"):
                listener.exitBefore_clause(self)

    def before_clause(self):

        localctx = JarlParser.Before_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_before_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 142
            self.match(JarlParser.BEFORE)
            self.state = 143
            self.checkpoint()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Between_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BETWEEN(self):
            return self.getToken(JarlParser.BETWEEN, 0)

        def checkpoint(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(JarlParser.CheckpointContext)
            else:
                return self.getTypedRuleContext(JarlParser.CheckpointContext, i)

        def AND(self):
            return self.getToken(JarlParser.AND, 0)

        def NEXT(self):
            return self.getToken(JarlParser.NEXT, 0)

        def PREVIOUS(self):
            return self.getToken(JarlParser.PREVIOUS, 0)

        def getRuleIndex(self):
            return JarlParser.RULE_between_clause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBetween_clause"):
                listener.enterBetween_clause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBetween_clause"):
                listener.exitBetween_clause(self)

    def between_clause(self):

        localctx = JarlParser.Between_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_between_clause)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 145
            self.match(JarlParser.BETWEEN)
            self.state = 146
            self.checkpoint()
            self.state = 147
            self.match(JarlParser.AND)
            self.state = 148
            _la = self._input.LA(1)
            if not(_la == JarlParser.NEXT or _la == JarlParser.PREVIOUS):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 149
            self.checkpoint()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Fact_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def checkpoint(self):
            return self.getTypedRuleContext(JarlParser.CheckpointContext, 0)

        def requirement(self):
            return self.getTypedRuleContext(JarlParser.RequirementContext, 0)

        def getRuleIndex(self):
            return JarlParser.RULE_fact_clause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFact_clause"):
                listener.enterFact_clause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFact_clause"):
                listener.exitFact_clause(self)

    def fact_clause(self):

        localctx = JarlParser.Fact_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_fact_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 151
            self.checkpoint()
            self.state = 152
            self.requirement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RequirementContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def requirement_count(self):
            return self.getTypedRuleContext(JarlParser.Requirement_countContext, 0)

        def requirement_order(self):
            return self.getTypedRuleContext(JarlParser.Requirement_orderContext, 0)

        def getRuleIndex(self):
            return JarlParser.RULE_requirement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRequirement"):
                listener.enterRequirement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRequirement"):
                listener.exitRequirement(self)

    def requirement(self):

        localctx = JarlParser.RequirementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_requirement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 156
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 16, self._ctx)
            if la_ == 1:
                self.state = 154
                self.requirement_count()
                pass

            elif la_ == 2:
                self.state = 155
                self.requirement_order()
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Requirement_countContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MUST(self):
            return self.getToken(JarlParser.MUST, 0)

        def HAPPEN(self):
            return self.getToken(JarlParser.HAPPEN, 0)

        def NOT(self):
            return self.getToken(JarlParser.NOT, 0)

        def how_many(self):
            return self.getTypedRuleContext(JarlParser.How_manyContext, 0)

        def getRuleIndex(self):
            return JarlParser.RULE_requirement_count

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRequirement_count"):
                listener.enterRequirement_count(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRequirement_count"):
                listener.exitRequirement_count(self)

    def requirement_count(self):

        localctx = JarlParser.Requirement_countContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_requirement_count)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 158
            self.match(JarlParser.MUST)
            self.state = 160
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == JarlParser.NOT:
                self.state = 159
                self.match(JarlParser.NOT)

            self.state = 162
            self.match(JarlParser.HAPPEN)
            self.state = 164
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == JarlParser.AT or _la == JarlParser.NUMBER:
                self.state = 163
                self.how_many()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Requirement_orderContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MUST(self):
            return self.getToken(JarlParser.MUST, 0)

        def PRECEDE(self):
            return self.getToken(JarlParser.PRECEDE, 0)

        def checkpoint(self):
            return self.getTypedRuleContext(JarlParser.CheckpointContext, 0)

        def NOT(self):
            return self.getToken(JarlParser.NOT, 0)

        def getRuleIndex(self):
            return JarlParser.RULE_requirement_order

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRequirement_order"):
                listener.enterRequirement_order(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRequirement_order"):
                listener.exitRequirement_order(self)

    def requirement_order(self):

        localctx = JarlParser.Requirement_orderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_requirement_order)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 166
            self.match(JarlParser.MUST)
            self.state = 168
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == JarlParser.NOT:
                self.state = 167
                self.match(JarlParser.NOT)

            self.state = 170
            self.match(JarlParser.PRECEDE)
            self.state = 171
            self.checkpoint()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class How_manyContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(JarlParser.NUMBER, 0)

        def TIMES(self):
            return self.getToken(JarlParser.TIMES, 0)

        def AT(self):
            return self.getToken(JarlParser.AT, 0)

        def MOST(self):
            return self.getToken(JarlParser.MOST, 0)

        def LEAST(self):
            return self.getToken(JarlParser.LEAST, 0)

        def getRuleIndex(self):
            return JarlParser.RULE_how_many

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterHow_many"):
                listener.enterHow_many(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitHow_many"):
                listener.exitHow_many(self)

    def how_many(self):

        localctx = JarlParser.How_manyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_how_many)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 177
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 20, self._ctx)
            if la_ == 1:
                self.state = 173
                self.match(JarlParser.AT)
                self.state = 174
                self.match(JarlParser.MOST)

            elif la_ == 2:
                self.state = 175
                self.match(JarlParser.AT)
                self.state = 176
                self.match(JarlParser.LEAST)

            self.state = 179
            self.match(JarlParser.NUMBER)
            self.state = 180
            self.match(JarlParser.TIMES)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Condition_listContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(JarlParser.ConditionContext)
            else:
                return self.getTypedRuleContext(JarlParser.ConditionContext, i)

        def getRuleIndex(self):
            return JarlParser.RULE_condition_list

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCondition_list"):
                listener.enterCondition_list(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCondition_list"):
                listener.exitCondition_list(self)

    def condition_list(self):

        localctx = JarlParser.Condition_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_condition_list)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 182
            self.condition()
            self.state = 187
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == JarlParser.T__0:
                self.state = 183
                self.match(JarlParser.T__0)
                self.state = 184
                self.condition()
                self.state = 189
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConditionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i: int = None):
            if i is None:
                return self.getTokens(JarlParser.IDENTIFIER)
            else:
                return self.getToken(JarlParser.IDENTIFIER, i)

        def COMPARATOR(self):
            return self.getToken(JarlParser.COMPARATOR, 0)

        def literal(self):
            return self.getTypedRuleContext(JarlParser.LiteralContext, 0)

        def getRuleIndex(self):
            return JarlParser.RULE_condition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCondition"):
                listener.enterCondition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCondition"):
                listener.exitCondition(self)

    def condition(self):

        localctx = JarlParser.ConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_condition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 190
            self.match(JarlParser.IDENTIFIER)
            self.state = 191
            self.match(JarlParser.COMPARATOR)
            self.state = 194
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JarlParser.IDENTIFIER]:
                self.state = 192
                self.match(JarlParser.IDENTIFIER)
                pass
            elif token in [JarlParser.NUMBER, JarlParser.LITERAL_STR]:
                self.state = 193
                self.literal()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class QuantifierContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ANY(self):
            return self.getToken(JarlParser.ANY, 0)

        def EVERY(self):
            return self.getToken(JarlParser.EVERY, 0)

        def getRuleIndex(self):
            return JarlParser.RULE_quantifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterQuantifier"):
                listener.enterQuantifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitQuantifier"):
                listener.exitQuantifier(self)

    def quantifier(self):

        localctx = JarlParser.QuantifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_quantifier)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 196
            _la = self._input.LA(1)
            if not(_la == JarlParser.ANY or _la == JarlParser.EVERY):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ArgumentsContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier_list(self):
            return self.getTypedRuleContext(JarlParser.Identifier_listContext, 0)

        def getRuleIndex(self):
            return JarlParser.RULE_arguments

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterArguments"):
                listener.enterArguments(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitArguments"):
                listener.exitArguments(self)

    def arguments(self):

        localctx = JarlParser.ArgumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_arguments)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 198
            self.match(JarlParser.T__1)
            self.state = 199
            self.identifier_list()
            self.state = 200
            self.match(JarlParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Identifier_listContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i: int = None):
            if i is None:
                return self.getTokens(JarlParser.IDENTIFIER)
            else:
                return self.getToken(JarlParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return JarlParser.RULE_identifier_list

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIdentifier_list"):
                listener.enterIdentifier_list(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIdentifier_list"):
                listener.exitIdentifier_list(self)

    def identifier_list(self):

        localctx = JarlParser.Identifier_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_identifier_list)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 210
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 24, self._ctx)
            if la_ == 1:
                self.state = 202
                self.match(JarlParser.IDENTIFIER)
                self.state = 207
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == JarlParser.T__0:
                    self.state = 203
                    self.match(JarlParser.T__0)
                    self.state = 204
                    self.match(JarlParser.IDENTIFIER)
                    self.state = 209
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CheckpointContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(JarlParser.IDENTIFIER, 0)

        def arguments(self):
            return self.getTypedRuleContext(JarlParser.ArgumentsContext, 0)

        def getRuleIndex(self):
            return JarlParser.RULE_checkpoint

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCheckpoint"):
                listener.enterCheckpoint(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCheckpoint"):
                listener.exitCheckpoint(self)

    def checkpoint(self):

        localctx = JarlParser.CheckpointContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_checkpoint)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 212
            self.match(JarlParser.IDENTIFIER)
            self.state = 213
            self.arguments()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LiteralContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LITERAL_STR(self):
            return self.getToken(JarlParser.LITERAL_STR, 0)

        def NUMBER(self):
            return self.getToken(JarlParser.NUMBER, 0)

        def getRuleIndex(self):
            return JarlParser.RULE_literal

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLiteral"):
                listener.enterLiteral(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLiteral"):
                listener.exitLiteral(self)

    def literal(self):

        localctx = JarlParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_literal)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 215
            _la = self._input.LA(1)
            if not(_la == JarlParser.NUMBER or _la == JarlParser.LITERAL_STR):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx
